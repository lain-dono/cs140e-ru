<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Основы операционных систем с нуля</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./about.html"><strong>1.</strong> О курсе</a></li><li><a href="./assignments.html"><strong>2.</strong> Задания</a></li><li><ul class="section"><li><a href="./assignment_0.html"><strong>2.1.</strong> Задание 0: Blinky</a></li></ul></li><li><a href="./rust_0.html"><strong>3.</strong> Rust</a></li><li><ul class="section"><li><a href="./rust_1.html"><strong>3.1.</strong> Основы синтаксиса</a></li><li><a href="./rust_2.html"><strong>3.2.</strong> Пользовательские типы</a></li><li><a href="./rust_3.html"><strong>3.3.</strong> Pattern matching</a></li><li><a href="./rust_4.html"><strong>3.4.</strong> Управляющие конструкции</a></li><li><a href="./rust_5.html"><strong>3.5.</strong> Память и указатели</a></li><li><a href="./rust_6.html"><strong>3.6.</strong> Инструментарий</a></li><li><a href="./rust_7.html"><strong>3.7.</strong> Стандартная библиотека</a></li></ul></li><li><a href="./git.html"><strong>4.</strong> Введение в Git и Github</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Основы операционных систем с нуля</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#Операционные-системы-с-нуля" id="Операционные-системы-с-нуля"><h1>Операционные системы с нуля</h1></a>
<a class="header" href="print.html#Об-этом-курсе" id="Об-этом-курсе"><h2>Об этом курсе</h2></a>
<a class="header" href="print.html#Материалы-курса" id="Материалы-курса"><h2>Материалы курса</h2></a>
<ul>
<li><a href="https://web.stanford.edu/class/cs140e/">Оригинальный курс CS140e</a></li>
<li><a href="https://web.stanford.edu/%7Eouster/cgi-bin/cs140-spring14/lectures.php">Лекции CS140 на английском</a></li>
<li><a href="https://news.ycombinator.com/item?id=16134618">Обсуждение на Hacker News</a></li>
<li><a href="https://www.reddit.com/r/cs140e/">Субреддит</a></li>
<li><a href="https://www.rust-lang.org/">Сайт Rust</a></li>
<li><a href="http://rurust.github.io/rust_book_ru/">Первое издание книги о Rust</a> (<a href="https://doc.rust-lang.org/stable/book/first-edition/">оригинал</a>)</li>
<li><a href="https://doc.rust-lang.org/stable/book/second-edition/">Второе издание на английском</a></li>
<li><a href="https://rurust.github.io/rust-by-example-ru/">Rust на примерах</a> (<a href="https://rustbyexample.com/">оригинал</a>)</li>
<li>Книга Operating Systems: Principles and Practice (ISBN-10: <code>0985673516</code> ISBN-13: <code>978-0985673512</code>)</li>
</ul>
<p>https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4
https://github.com/nikomatsakis/rust-memory-model
-&gt; from <a href="https://www.reddit.com/r/rust/comments/7p6n90/rust2018_back_to_the_roots/">reddit</a> <a href="https://habrahabr.ru/post/346644/">перевод</a></p>
<a class="header" href="print.html#Задания" id="Задания"><h1>Задания</h1></a>
<a class="header" href="print.html#Задание-0-blinky" id="Задание-0-blinky"><h1>Задание 0: Blinky</h1></a>
<a class="header" href="print.html#Материалы" id="Материалы"><h2>Материалы</h2></a>
<p><a href="./docs/BCM2835-ARM-Peripherals.pdf">BCM2835 ARM Peripherals Manual</a></p>
<p><a href="https://learn.sparkfun.com/tutorials/how-to-use-a-breadboard">How to Use a Breadboard</a></p>
<p><a href="https://www.raspberrypi.org/documentation/usage/gpio-plus-and-raspi2/README.md">Raspberry Pi Foundation’s GPIO Usage</a></p>
<a class="header" href="print.html#Предисловие" id="Предисловие"><h2>Предисловие</h2></a>
<p>Добро пожаловать в CS140e!
Мы очень рады, что вы решили присоединиться к нам для этого инаугурационного воплощения.
Надеемся, вам понравится этот класс, поскольку мы его разработали!
И, конечно же, мы надеемся, что вы узнаете тонну.</p>
<p>Мы надеемся сделать что-то по-другому в CS140e, чем в норме.
В частности, мы хотим, чтобы вы написали большую часть кода, и мы хотим,
чтобы ваш код исполнялся на реальном оборудовании, делая реальные вещи.
Для вас будет очень мало строительных лесов, и весь ваш код будет нацелен и запускаться на встроенной платформе Raspberry Pi 3,
основанной на четырехъядерных процессорах ARMv8 Cortex-A53.</p>
<p>В CS140e вы будете программировать в Rust,
«язык системного программирования, который работает невероятно быстро, предотвращает segfaults и гарантирует безопасность потоков».
Вы можете думать о Rust как о преемнике C и C ++, но более полезно думать это новый язык с новыми концепциями.
Не пытайтесь программировать в Rust, как если бы это C, C ++, Java или любой другой язык, к которому вы привыкли.
Вместо этого рассмотрите это как возможность изучить новый способ написания программного обеспечения - новый ржавый способ.
К концу срока мы думаем, вы согласитесь, что Rust поможет вам написать более правильное,
более надежное программное обеспечение - ключевые свойства для операционных систем!</p>
<p>Вы будете писать много кода в CS140e, хотя мы думаем,
что большая часть вашего времени будет потрачена, думая о том, что должно произойти.
Мы ожидаем, что для большинства заданий потребуется около 10-15 часов в неделю.
Вы ни в коем случае не должны затягиваться в CS140e.
Начните пораньше, задавайте вопросы и получайте удовольствие - вы узнаете гораздо больше,
если вы дадите себе возможность подумать о трудных проблемах.</p>
<p>Мы здесь, чтобы ответить на все вопросы. Пожалуйста, не стесняйтесь обращаться к нам. Удачи!</p>
<a class="header" href="print.html#Обзор" id="Обзор"><h2>Обзор</h2></a>
<p>В этом задании вы настроите и испытаете среду разработки Raspberry Pi 3,
ARM64 для вашего использования на протяжении всего курса.
Вы установите необходимые инструменты и напишите свое первое приложение с белым металлом,
светодиодная мигающая программа на двух языках: C и Rust.</p>
<p>Это назначение разделено на 4 фазы.
На первом этапе вы установите необходимое программное обеспечение для связи с вашим Pi с вашего компьютера.
Вы также убедитесь, что ваш Pi работает так, как ожидалось, запустив предварительно скомпилированную программу.
На втором этапе вы подключите вывод 16 GPIO на вашем малине Pi к светодиоду на макете
и запустите вторую предварительно скомпилированную программу, чтобы обеспечить надежное соединение.
На третьем этапе вы установите кросс-компилятор aarch64-none-elf,
который позволит вам скомпилировать и связать программы для вашего Pi с вашей машины.
Вы будете писать, компилировать и связывать программу C, которая включает и выключает вывод 16 GPIO,
мигая светодиод, подключенный к вашему Pi.
Наконец, в фазе 4 вы установите Rust и необходимую инструментальную цепочку для записи,
компиляции и связывания одной и той же программы в Rust.</p>
<a class="header" href="print.html#0-Начало-работы" id="0-Начало-работы"><h2>0: Начало работы</h2></a>
<p>Во-первых, убедитесь, что вы работаете над этим заданием с помощью совместимой машины.
Для CS140e совместимость означает соотвествие следующим требованиям:</p>
<ul>
<li>В качестве ОС современная вариация Unix (не виртуалка): Linux, BSD или macOS</li>
<li>64-битный вариант этой ОС</li>
<li>Имеются порты USB-A (или USB-C с USB-A адаптером)</li>
</ul>
<p>И там установленно следующее програмное обеспечение:
<code>git</code>, <code>wget</code>, <code>tar</code>, <code>screen</code> и <code>make</code>.</p>
<p>Если вы используете Windows, мы предлагаем вам установить
<a href="https://www.ubuntu.com/download/desktop">Ubuntu LTS</a>
или
<a href="https://getfedora.org/en/workstation/download/">Fedora</a>
на дополнительный раздел.
Возможно использовать <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Linux Subsystem for Windows</a>,
но на данный момент мы
не будем предоставлять поддержку или отвечать на вопросы об этой конфигурации.</p>
<a class="header" href="print.html#Получение-железа" id="Получение-железа"><h3>Получение “железа”</h3></a>
<p>Убедитесь, что у вас в наличии:</p>
<ul>
<li>1 Raspberry Pi 3 model B</li>
<li>1 1/2-sized breadboard</li>
<li>1 microSD-карта на 4GB</li>
<li>1 адаптер для microSD-карт</li>
<li>1 CP2102 USB TTL adapter w/4 jumper cables</li>
<li>10 многоцветных светодиодов</li>
<li>4 резистора по 100 ом</li>
<li>4 резистора по 1 килоом</li>
<li>20 соеденительных проводов</li>
</ul>
<p><strong>Внимание</strong>:
Электроника чувствительна к статическому электричеству, поэтому убедитесь,
что вы заземляете себя, касаясь чего-то проводящего, прежде чем прикасаться к любой электронике.</p>
<p>Подготовьте два проводка, один резистор (любой из вышеперечисленных) и один светодиод.
Чуть позже нам пригодится и карта с адаптером.</p>
<a class="header" href="print.html#Получение-стартового-кода" id="Получение-стартового-кода"><h3>Получение стартового кода</h3></a>
<p>Склонируйте нулевое задание из git-репозитория на вашу машину разработчика
и затем извлеките необходимые файлы, запустив <code>make fetch</code> внутри каталога:</p>
<pre><code>git clone https://web.stanford.edu/class/cs140e/assignments/0-blinky/skeleton.git assignment0
cd assignment0
make fetch
</code></pre>
<p>Не стесняйтесь самостоятельно исследовать содержимое репозитория.</p>
<a class="header" href="print.html#1-Подготовка-pi" id="1-Подготовка-pi"><h2>1: Подготовка Pi</h2></a>
<a class="header" href="print.html#2-Зажигаем-светодиод" id="2-Зажигаем-светодиод"><h2>2: Зажигаем светодиод</h2></a>
<a class="header" href="print.html#3-Няшный-Си" id="3-Няшный-Си"><h2>3: Няшный Си</h2></a>
<a class="header" href="print.html#4-Ржавчина" id="4-Ржавчина"><h2>4: Ржавчина</h2></a>
<a class="header" href="print.html#rust" id="rust"><h1>Rust</h1></a>
<p>Rust - это современный язык программирования,
разработанный <a href="https://research.mozilla.org/">Mozilla Research</a>.
Rust сочетает тонкий контроль над производительностью
с удобством высокого уровня и гарантиями безопасности.</p>
<p>Он достигает этих целей,
не требуя сборщика мусора или времени выполнения,
что позволяет использовать библиотеки Rust в качестве прозрачной замены для C.</p>
<p>Первый выпуск Rust (версия 0.1), произошел в январе 2012 года,
и в течении следующих 3 лет развивался настолько быстро,
что до недавнего времени не было стабильных выпусков.
Вместо них можно было использовать только ежедневные “ночные сборки”.</p>
<p>15 мая 2015 года был выпущен Rust 1.0 с полной гарантией обратной совместимости.
Усовершенствования времени компиляции и других аспектов компилятора в настоящее время доступны в ночных сборках.
Rust приняла модель выпуска на поезде с регулярными выпусками каждые шесть недель.
Rust 1.1 beta был доступен одновременно с выпуском Rust 1.0.</p>
<p>Хотя Rust является языком относительно низкого уровня,
Rust имеет некоторые функциональные концепции,
которые обычно встречаются на языках более высокого уровня.
Благодаря этому Rust не только быстрый при выполнении, но также простой и эффективный для ввода кода.</p>
<p>На момент написания этого текста актуальной стабильной версией является 1.23.</p>
<a class="header" href="print.html#Материалы-1" id="Материалы-1"><h2>Материалы</h2></a>
<p>https://rurust.github.io/rust-by-example-ru/index.html</p>
<a class="header" href="print.html#Основы-синтаксиса" id="Основы-синтаксиса"><h1>Основы синтаксиса</h1></a>
<pre><pre class="playpen"><code class="language-rust">// Это комментарий. Однострочные комментарии выглядят примерно так...

/*
    Многострочный
    комментарий
*/

/// Комментарии-документация выглядят примерно так и поддерживают markdown-разметку.
/// # Пример
///
/// ```
/// let five = 5
/// ```

// Функции.
// `i32` это тип для 32-разрядных целых чисел со знаком (4 байта в памяти)
fn add2(x: i32, y: i32) -&gt; i32 {
    // Неявный return (без ;)
    x + y
    // Можно также использовать явный return: return x + y;
    // Вызов этой функции: add2(1, 3)
}

// Функция Main
// Отсюда начинается выполнение программы
fn main() {
    // Числа //

    // Неизменяемые привязки
    let x: i32 = 1;
    // x = 3; &lt;-- ошибка времени компиляции

    // Изменяемые переменные
    let mut mutable = 1;
    mutable = 4;
    mutable += 2;

    // Суфиксы для целых чисел(integer) и чисел с плавающей запятой(float)
    let y: i32 = 13i32;
    let f: f64 = 1.3f64;

    // Вывод типов
    //
    // В большинстве случаев компилятор Rust может сам определить тип переменной,
    // поэтому вам не нужно писать явное аннотирование типа.
    // В этом учебном пособии типы явно аннотируются
    // во многих местах в демонстрационных целях.
    // Вывод типов может справиться с этим для вас большую часть времени.

    let implicit_x = 1;
    let implicit_f = 1.3;

    // Арифметика
    let sum = x + y + 13;

    // Строки //

    // Строковые литералы
    let x: &amp;str = &quot;hello world!&quot;;

    // Вывод в консоль
    println!(&quot;{} {}&quot;, f, x); // 1.3 hello world

    // `String` - строка в динамически выделенной памяти
    let s: String = &quot;hello world&quot;.into();
    let s2: String = &quot;hello world&quot;.to_string();
    let s3: String = String::from(&quot;hello world&quot;);

    // A string slice: an immutable view into another string.
    //
    // This is essentially an immutable pair of pointers to a string - it
    // doesn't actually contain the contents of a string, just a pointer to the
    // begin and a pointer to the end of a string buffer, statically allocated
    // or contained in another object (in this case, `s`)
    let s_slice: &amp;str = &amp;s;
    let s_slice2: &amp;str = &amp;s[6..11];
    let s_slice3: &amp;str = &amp;s[6..];
    let s_slice4: &amp;str = &amp;s[..5];

    println!(&quot;{} {}&quot;, s, s_slice); // hello world hello world

    // Vectors/arrays //

    // A fixed-size array
    let four_ints: [i32; 4] = [1, 2, 3, 4];

    // A dynamic array (vector)
    let mut vector: Vec&lt;i32&gt; = vec![1, 2, 3, 4];
    vector.push(5);

    // Mutability is inherited by the bound value. If `vector` is not declared
    // `mut`, then the value cannot be mutated.
    let vector: Vec&lt;i32&gt; = vec![1, 2, 3, 4, 5];
    // vector.push(5); &lt;-- compile-time error

    // A slice - an immutable view into a vector or array.
    let slice: &amp;[i32] = &amp;vector;
    let slice2: &amp;[i32] = &amp;vector[1..4];

    // Use `{:?}` to print something debug-style
    println!(&quot;{:?} | {:?}&quot;, vector, slice2); // [1, 2, 3, 4, 5] | [2, 3, 4]

    // Array, slice, and vector indexing.
    println!(&quot;{}&quot;, four_ints[1]); // 2
    println!(&quot;{}&quot;, vector[2]); // 3
    println!(&quot;{}&quot;, slice[3]); // 4

    // Tuples //

    // A tuple is a fixed-size set of values of possibly different types
    let x: (i32, &amp;str, f64) = (1, &quot;hello&quot;, 3.4);

    // Destructuring `let`
    let (a, b, c) = x;
    println!(&quot;{} {} {}&quot;, a, b, c); // 1 hello 3.4
    // Structures can also be destructured on assignment, as we'll see later.

    // Tuple indexing.
    println!(&quot;{}&quot;, x.1); // hello
}
</code></pre></pre>
<a class="header" href="print.html#Пользовательские-типы" id="Пользовательские-типы"><h1>Пользовательские типы</h1></a>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Struct
    struct Point {
        x: i32,
        y: i32,
    }

    let origin: Point = Point { x: 0, y: 0 };

    // A struct with unnamed fields, called a ‘tuple struct’
    struct Point2(i32, i32);

    let origin2 = Point2(0, 0);

    // Basic C-like enum
    enum Direction {
        Left,
        Right,
        Up,
        Down,
    }

    let up = Direction::Up;

    // Enum with fields
    enum OptionalI32 {
        AnI32(i32),
        Nothing,
    }

    let two: OptionalI32 = OptionalI32::AnI32(2);
    let nothing = OptionalI32::Nothing;

    // Generics //

    struct Foo&lt;T&gt; { bar: T }

    // This is defined in the standard library as `Option`
    enum Optional&lt;T&gt; {
        SomeVal(T),
        NoVal,
    }

    // Methods //

    impl&lt;T&gt; Foo&lt;T&gt; {
        // Methods take an explicit `self` parameter
        fn get_bar(self) -&gt; T {
            self.bar
        }
    }

    let a_foo = Foo { bar: 1 };
    println!(&quot;{}&quot;, a_foo.get_bar()); // 1

    // Traits (known as interfaces or typeclasses in other languages) //

    trait Frobnicate&lt;T&gt; {
        fn frobnicate(self) -&gt; Option&lt;T&gt;;
    }

    impl&lt;T&gt; Frobnicate&lt;T&gt; for Foo&lt;T&gt; {
        fn frobnicate(self) -&gt; Option&lt;T&gt; {
            Some(self.bar)
        }
    }

    let another_foo = Foo { bar: 1 };
    println!(&quot;{:?}&quot;, another_foo.frobnicate()); // Some(1)
}
</code></pre></pre>
<a class="header" href="print.html#pattern-matching" id="pattern-matching"><h1>Pattern matching</h1></a>
<p>Сопоставление с образцом</p>
<pre><pre class="playpen"><code class="language-rust">enum OptionalI32 {
    AnI32(i32),
    Nothing,
}

fn main() {
    let foo = OptionalI32::AnI32(1);
    match foo {
        OptionalI32::AnI32(n) =&gt; println!(&quot;it’s an i32: {}&quot;, n),
        OptionalI32::Nothing  =&gt; println!(&quot;it’s nothing!&quot;),
    }

    // Advanced pattern matching
    struct FooBar { x: i32, y: OptionalI32 }
    let bar = FooBar { x: 15, y: OptionalI32::AnI32(32) };

    match bar {
        FooBar { x: 0, y: OptionalI32::AnI32(0) } =&gt;
            println!(&quot;The numbers are zero!&quot;),
        FooBar { x: n, y: OptionalI32::AnI32(m) } if n == m =&gt;
            println!(&quot;The numbers are the same&quot;),
        FooBar { x: n, y: OptionalI32::AnI32(m) } =&gt;
            println!(&quot;Different numbers: {} {}&quot;, n, m),
        FooBar { x: _, y: OptionalI32::Nothing } =&gt;
            println!(&quot;The second number is Nothing!&quot;),
    }
}
</code></pre></pre>
<a class="header" href="print.html#Управляющие-конструкции" id="Управляющие-конструкции"><h1>Управляющие конструкции</h1></a>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // `for` loops/iteration
    let array = [1, 2, 3];
    for i in array.iter() {
        println!(&quot;{}&quot;, i);
    }

    // Ranges
    for i in 0u32..10 {
        print!(&quot;{} &quot;, i);
    }
    println!(&quot;&quot;);
    // prints `0 1 2 3 4 5 6 7 8 9 `

    // `if`
    if 1 == 1 {
        println!(&quot;Maths is working!&quot;);
    } else {
        println!(&quot;Oh no...&quot;);
    }

    // `if` as expression
    let value = if true {
        &quot;good&quot;
    } else {
        &quot;bad&quot;
    };

    // `while` loop
    while 1 == 1 {
        println!(&quot;The universe is operating normally.&quot;);
    }

    // Infinite loop
    loop {
        println!(&quot;Hello!&quot;);
    }
}
</code></pre></pre>
<a class="header" href="print.html#Память-и-указатели" id="Память-и-указатели"><h1>Память и указатели</h1></a>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Owned pointer – only one thing can ‘own’ this pointer at a time
    // This means that when the `Box` leaves its scope, it can be automatically deallocated safely.
    let mut mine: Box&lt;i32&gt; = Box::new(3);
    *mine = 5; // dereference
    // Here, `now_its_mine` takes ownership of `mine`. In other words, `mine` is moved.
    let mut now_its_mine = mine;
    *now_its_mine += 2;

    println!(&quot;{}&quot;, now_its_mine); // 7
    // println!(&quot;{}&quot;, mine); // this would not compile because `now_its_mine` now owns the pointer

    // Reference – an immutable pointer that refers to other data
    // When a reference is taken to a value, we say that the value has been ‘borrowed’.
    // While a value is borrowed immutably, it cannot be mutated or moved.
    // A borrow lasts until the end of the scope it was created in.
    let mut var = 4;
    var = 3;
    let ref_var: &amp;i32 = &amp;var;

    println!(&quot;{}&quot;, var); // Unlike `mine`, `var` can still be used
    println!(&quot;{}&quot;, *ref_var);
    // var = 5; // this would not compile because `var` is borrowed
    // *ref_var = 6; // this would not either, because `ref_var` is an immutable reference

    // Mutable reference
    // While a value is mutably borrowed, it cannot be accessed at all.
    let mut var2 = 4;
    let ref_var2: &amp;mut i32 = &amp;mut var2;
    *ref_var2 += 2;         // '*' is used to point to the mutably borrowed var2

    println!(&quot;{}&quot;, *ref_var2); // 6 , // var2 would not compile.
    // ref_var2 is of type &amp;mut i32, so stores a reference to an i32, not the value.
    // var2 = 2; // this would not compile because `var2` is borrowed.
}
</code></pre></pre>
<a class="header" href="print.html#Инструментарий" id="Инструментарий"><h1>Инструментарий</h1></a>
<a class="header" href="print.html#Стандартная-библиотека" id="Стандартная-библиотека"><h1>Стандартная библиотека</h1></a>
<a class="header" href="print.html#Введение-в-git-и-github" id="Введение-в-git-и-github"><h1>Введение в Git и Github</h1></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        
        <script type="text/javascript" src="svg.min.js"></script>
        

    </body>
</html>
